#!/bin/bash
# Voice Clone Userbot - Auto Deploy Script (24/7)
# Save as: auto_deploy.sh (rename from .txt)
# Usage: chmod +x auto_deploy.sh && ./auto_deploy.sh

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

print_step() {
    echo -e "${YELLOW}[STEP]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_header() {
    echo -e "${BLUE}"
    echo "=============================================="
    echo "üöÄ Voice Clone Userbot Auto Deploy 24/7"
    echo "=============================================="
    echo -e "${NC}"
}

install_python_if_missing() {
    print_step "Checking Python installation..."
    
    if ! command -v python3 &> /dev/null; then
        print_step "Installing Python3..."
        sudo apt update
        sudo apt install -y python3 python3-pip python3-venv
    fi
    
    if ! command -v python3 -m venv --help &> /dev/null; then
        print_step "Installing python3-venv..."
        sudo apt install -y python3-venv
    fi
    
    print_success "Python3 and venv ready"
}

create_project_structure() {
    print_step "Creating project structure..."
    
    # Create directories
    mkdir -p logs backups sessions
    
    # Create requirements.txt
    cat > requirements.txt << 'EOF'
# Voice Clone Userbot Requirements - Fixed Versions
numpy==1.24.3
scipy==1.11.1
sounddevice==0.4.6
pyrogram==2.0.106
tgcrypto==1.2.5
pathlib2==2.3.7; python_version<"3.4"
EOF
    
    # Create main bot script
    cat > voice_clone_bot.py << 'EOF'
#!/usr/bin/env python3
"""
Voice Clone Userbot with Real-time Voice Modification
Supports character voices: Jokowi, Squidward, SpongeBob, Ganjar, Clara
"""

import os
import sys
import asyncio
import threading
import numpy as np
import sounddevice as sd
from scipy.signal import resample, butter, filtfilt
import logging
from pyrogram import Client, filters
from pyrogram.errors import SessionPasswordNeeded, PhoneCodeInvalid, PhoneNumberInvalid
import json
from pathlib import Path
import time

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/bot.log'),
        logging.StreamHandler()
    ]
)

class Config:
    API_ID = 29919905
    API_HASH = "717957f0e3ae20a7db004d08b66bfd30"
    PHONE_NUMBER = "+6283199218067"
    
    SAMPLE_RATE = 44100
    BUFFER_SIZE = 1024
    SESSION_NAME = "voice_clone_userbot"
    
    VOICE_CHARACTERS = {
        "jokowi": {
            "name": "Joko Widodo",
            "pitch_factor": 0.85,
            "formant_shift": 0.9,
            "speaking_rate": 0.9,
            "tone_profile": "authoritative"
        },
        "squidward": {
            "name": "Squidward Tentacles", 
            "pitch_factor": 0.7,
            "formant_shift": 1.1,
            "speaking_rate": 0.8,
            "tone_profile": "nasal"
        },
        "spongebob": {
            "name": "SpongeBob SquarePants",
            "pitch_factor": 1.4,
            "formant_shift": 1.3,
            "speaking_rate": 1.2,
            "tone_profile": "excited"
        },
        "ganjar": {
            "name": "Ganjar Pranowo",
            "pitch_factor": 0.9,
            "formant_shift": 0.95,
            "speaking_rate": 1.0,
            "tone_profile": "friendly"
        },
        "clara": {
            "name": "Clara Mongstar",
            "pitch_factor": 1.2,
            "formant_shift": 1.15,
            "speaking_rate": 1.1,
            "tone_profile": "energetic"
        }
    }

class VoiceCloneEngine:
    def __init__(self):
        self.is_active = False
        self.current_character = "normal"
        self.audio_thread = None
        self.input_stream = None
        self.output_stream = None
        self.processing_lock = threading.Lock()
        
        self.sample_rate = Config.SAMPLE_RATE
        self.buffer_size = Config.BUFFER_SIZE
        self.audio_buffer = np.zeros(self.buffer_size * 4)
        self.buffer_index = 0
        
    def apply_character_voice(self, audio_data, character):
        if character == "normal" or character not in Config.VOICE_CHARACTERS:
            return audio_data
            
        char_config = Config.VOICE_CHARACTERS[character]
        processed = audio_data.copy()
        
        try:
            if char_config["pitch_factor"] != 1.0:
                processed = self.pitch_shift(processed, char_config["pitch_factor"])
            
            if char_config["formant_shift"] != 1.0:
                processed = self.formant_shift(processed, char_config["formant_shift"])
            
            tone = char_config["tone_profile"]
            if tone == "nasal":
                processed = self.apply_nasal_effect(processed)
            elif tone == "excited":
                processed = self.apply_excitement_effect(processed)
            elif tone == "authoritative":
                processed = self.apply_authority_effect(processed)
            elif tone == "friendly":
                processed = self.apply_warmth_effect(processed)
            elif tone == "energetic":
                processed = self.apply_energy_effect(processed)
                
            return processed
            
        except Exception as e:
            logging.error(f"Character voice processing error: {e}")
            return audio_data
    
    def pitch_shift(self, audio_data, factor):
        if factor == 1.0:
            return audio_data
            
        new_length = int(len(audio_data) * factor)
        if new_length > 0:
            shifted = resample(audio_data, new_length)
            
            if len(shifted) < len(audio_data):
                padded = np.zeros(len(audio_data))
                padded[:len(shifted)] = shifted
                return padded
            else:
                return shifted[:len(audio_data)]
        return audio_data
    
    def formant_shift(self, audio_data, factor):
        if factor == 1.0:
            return audio_data
            
        nyquist = self.sample_rate / 2
        
        if factor > 1.0:
            low = 200 / nyquist
            high = min(3000 * factor, nyquist - 100) / nyquist
            b, a = butter(4, [low, high], btype='band')
            return filtfilt(b, a, audio_data)
        else:
            cutoff = min(2000 * factor, nyquist - 100) / nyquist
            b, a = butter(4, cutoff, btype='low')
            return filtfilt(b, a, audio_data)
    
    def apply_nasal_effect(self, audio_data):
        nyquist = self.sample_rate / 2
        low = 1000 / nyquist
        high = 2000 / nyquist
        b, a = butter(2, [low, high], btype='band')
        filtered = filtfilt(b, a, audio_data)
        return audio_data + 0.3 * filtered
    
    def apply_excitement_effect(self, audio_data):
        t = np.arange(len(audio_data)) / self.sample_rate
        tremolo = 1 + 0.1 * np.sin(2 * np.pi * 5 * t)
        
        nyquist = self.sample_rate / 2
        cutoff = 2000 / nyquist
        b, a = butter(2, cutoff, btype='high')
        high_boost = filtfilt(b, a, audio_data)
        
        return (audio_data + 0.2 * high_boost) * tremolo
    
    def apply_authority_effect(self, audio_data):
        nyquist = self.sample_rate / 2
        low = 150 / nyquist  
        high = 800 / nyquist
        b, a = butter(3, [low, high], btype='band')
        filtered = filtfilt(b, a, audio_data)
        return audio_data + 0.25 * filtered
    
    def apply_warmth_effect(self, audio_data):
        nyquist = self.sample_rate / 2
        cutoff = 500 / nyquist
        b, a = butter(2, cutoff, btype='low')
        warm = filtfilt(b, a, audio_data)
        return audio_data + 0.15 * warm
    
    def apply_energy_effect(self, audio_data):
        nyquist = self.sample_rate / 2
        cutoff = 1500 / nyquist
        b, a = butter(2, cutoff, btype='high')
        bright = filtfilt(b, a, audio_data)
        
        threshold = 0.3
        compressed = np.where(np.abs(audio_data) > threshold,
                            threshold + (audio_data - threshold) * 0.5,
                            audio_data)
        
        return compressed + 0.2 * bright
    
    def audio_callback(self, indata, outdata, frames, time, status):
        if status:
            logging.warning(f"Audio status: {status}")
        
        try:
            with self.processing_lock:
                mono_input = indata[:, 0] if len(indata.shape) > 1 else indata
                processed = self.apply_character_voice(mono_input, self.current_character)
                processed = np.clip(processed, -0.95, 0.95)
                outdata[:, 0] = processed
                
        except Exception as e:
            logging.error(f"Audio callback error: {e}")
            outdata[:] = indata
    
    def start_voice_clone(self, character="normal"):
        if self.is_active:
            self.stop_voice_clone()
            
        try:
            self.current_character = character
            self.is_active = True
            
            with sd.InputStream(callback=self.audio_callback,
                              channels=1,
                              samplerate=self.sample_rate,
                              blocksize=self.buffer_size):
                with sd.OutputStream(callback=self.audio_callback,
                                   channels=1,
                                   samplerate=self.sample_rate,
                                   blocksize=self.buffer_size):
                    
                    logging.info(f"Voice clone started with character: {character}")
                    
                    while self.is_active:
                        sd.sleep(100)
                        
        except Exception as e:
            logging.error(f"Voice clone start error: {e}")
            self.is_active = False
            
    def stop_voice_clone(self):
        self.is_active = False
        logging.info("Voice clone stopped")

class UserBotSession:
    def __init__(self):
        self.client = None
        self.session_file = f"sessions/{Config.SESSION_NAME}.session"
        
    async def create_session(self):
        try:
            self.client = Client(
                f"sessions/{Config.SESSION_NAME}",
                api_id=Config.API_ID,
                api_hash=Config.API_HASH,
                phone_number=Config.PHONE_NUMBER
            )
            
            await self.client.start()
            
            session_info = {
                "api_id": Config.API_ID,
                "api_hash": Config.API_HASH,
                "phone_number": Config.PHONE_NUMBER,
                "session_created": True
            }
            
            with open("sessions/session_info.json", "w") as f:
                json.dump(session_info, f, indent=2)
                
            logging.info("‚úÖ Session created successfully!")
            return self.client
            
        except SessionPasswordNeeded:
            password = input("üîê Enter your 2FA password: ")
            await self.client.check_password(password)
            logging.info("‚úÖ 2FA verification successful!")
            return self.client
            
        except PhoneCodeInvalid:
            logging.error("‚ùå Invalid phone code!")
            return None
            
        except Exception as e:
            logging.error(f"‚ùå Session creation error: {e}")
            return None

class VoiceCloneUserBot:
    def __init__(self):
        self.voice_engine = VoiceCloneEngine()
        self.session_handler = UserBotSession()
        self.client = None
        
    async def initialize(self):
        print("üöÄ Initializing Voice Clone UserBot...")
        print(f"üì± Phone: {Config.PHONE_NUMBER}")
        print("=" * 50)
        
        self.client = await self.session_handler.create_session()
        if not self.client:
            print("‚ùå Failed to create session!")
            return False
            
        self.setup_handlers()
        return True
    
    def setup_handlers(self):
        @self.client.on_message(filters.command("voice") & filters.me)
        async def voice_command(client, message):
            try:
                args = message.text.split()[1:] if len(message.text.split()) > 1 else []
                
                if not args:
                    await message.edit("üé§ **Voice Clone Commands:**\n\n"
                                     "`.voice start <character>` - Start voice clone\n"
                                     "`.voice stop` - Stop voice clone\n"
                                     "`.voice list` - List characters\n"
                                     "`.voice status` - Show status")
                    return
                
                if args[0] == "start":
                    character = args[1] if len(args) > 1 else "normal"
                    
                    if character not in ["normal"] + list(Config.VOICE_CHARACTERS.keys()):
                        await message.edit(f"‚ùå Character '{character}' not found!\n"
                                         f"Available: {', '.join(['normal'] + list(Config.VOICE_CHARACTERS.keys()))}")
                        return
                    
                    def start_clone():
                        self.voice_engine.start_voice_clone(character)
                    
                    if not self.voice_engine.is_active:
                        threading.Thread(target=start_clone, daemon=True).start()
                        
                        char_name = Config.VOICE_CHARACTERS.get(character, {}).get("name", character)
                        await message.edit(f"üé≠ **Voice Clone Started!**\n"
                                         f"Character: **{char_name}**\n"
                                         f"Status: **Active** ‚úÖ")
                    else:
                        await message.edit("‚ö†Ô∏è Voice clone already active!")
                
                elif args[0] == "stop":
                    self.voice_engine.stop_voice_clone()
                    await message.edit("üõë **Voice Clone Stopped!**")
                
                elif args[0] == "list":
                    char_list = "üé≠ **Available Characters:**\n\n"
                    for key, info in Config.VOICE_CHARACTERS.items():
                        char_list += f"‚Ä¢ `{key}` - {info['name']}\n"
                    char_list += f"‚Ä¢ `normal` - Original Voice"
                    await message.edit(char_list)
                
                elif args[0] == "status":
                    status = "Active ‚úÖ" if self.voice_engine.is_active else "Inactive ‚ùå"
                    char_name = Config.VOICE_CHARACTERS.get(
                        self.voice_engine.current_character, {}
                    ).get("name", self.voice_engine.current_character)
                    
                    await message.edit(f"üé§ **Voice Clone Status:**\n\n"
                                     f"Status: **{status}**\n"
                                     f"Character: **{char_name}**\n"
                                     f"Sample Rate: {Config.SAMPLE_RATE} Hz")
                
            except Exception as e:
                await message.edit(f"‚ùå Error: {str(e)}")
        
        @self.client.on_message(filters.command("quick") & filters.me)
        async def quick_voice_change(client, message):
            args = message.text.split()[1:] if len(message.text.split()) > 1 else []
            
            if not args:
                await message.edit("Usage: `.quick <character>`")
                return
            
            character = args[0]
            if character in Config.VOICE_CHARACTERS:
                self.voice_engine.current_character = character
                char_name = Config.VOICE_CHARACTERS[character]["name"]
                await message.edit(f"üé≠ Switched to: **{char_name}**", delete_in=3)
            else:
                await message.edit(f"‚ùå Character not found: {character}", delete_in=3)
    
    async def run(self):
        if await self.initialize():
            print("üéâ Voice Clone UserBot is running!")
            print("Commands:")
            print("  .voice start <character> - Start voice cloning")
            print("  .voice stop - Stop voice cloning")  
            print("  .voice list - List available characters")
            print("  .quick <character> - Quick character switch")
            print("\nPress Ctrl+C to stop")
            
            try:
                await self.client.idle()
            except KeyboardInterrupt:
                print("\nüëã Shutting down...")
                self.voice_engine.stop_voice_clone()
        else:
            print("‚ùå Failed to start userbot!")

async def main():
    userbot = VoiceCloneUserBot()
    await userbot.run()

if __name__ == "__main__":
    try:
        import pyrogram
        import scipy
        import sounddevice
        import numpy
        
        print("üîä Voice Clone UserBot")
        print("=" * 30)
        print("Dependencies: ‚úÖ All installed")
        print()
        
        asyncio.run(main())
        
    except ImportError as e:
        print(f"‚ùå Missing dependency: {e}")
        print("\nüì¶ Install required packages:")
        print("pip install pyrogram scipy sounddevice numpy tgcrypto")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Error: {e}")
        sys.exit(1)
EOF
    
    print_success "Project structure created"
}

setup_virtual_environment() {
    print_step "Setting up virtual environment..."
    
    # Remove existing venv
    if [ -d "venv" ]; then
        print_step "Removing old virtual environment..."
        rm -rf venv
    fi
    
    # Create new venv
    print_step "Creating new virtual environment..."
    python3 -m venv venv
    
    # Activate and upgrade
    source venv/bin/activate
    print_step "Upgrading pip and installing wheel..."
    pip install --upgrade pip wheel setuptools
    
    print_success "Virtual environment ready"
}

install_system_dependencies() {
    print_step "Installing system dependencies..."
    
    # Update system
    sudo apt update
    
    # Install audio dependencies
    sudo apt install -y \
        portaudio19-dev \
        libasound2-dev \
        pulseaudio \
        pulseaudio-utils \
        build-essential \
        python3-dev
    
    # Start PulseAudio
    pulseaudio --start --daemonize || true
    
    print_success "System dependencies installed"
}

install_python_packages() {
    print_step "Installing Python packages..."
    
    source venv/bin/activate
    
    # Install packages one by one for better error handling
    packages=(
        "numpy==1.24.3"
        "scipy==1.11.1"
        "pyrogram==2.0.106"
        "tgcrypto==1.2.5"
        "sounddevice==0.4.6"
    )
    
    for package in "${packages[@]}"; do
        print_step "Installing $package..."
        pip install "$package" --no-cache-dir
        if [ $? -ne 0 ]; then
            print_error "Failed to install $package, trying alternative..."
            pip install "$package" --user --no-cache-dir
        fi
    done
    
    print_success "Python packages installed"
}

create_service_file() {
    print_step "Creating systemd service..."
    
    cat > voice-clone-userbot.service << EOF
[Unit]
Description=Voice Clone Userbot 24/7
After=network.target sound.target
Wants=network-online.target

[Service]
Type=simple
User=$USER
Group=$USER
WorkingDirectory=$(pwd)
Environment=PATH=$(pwd)/venv/bin:/usr/local/bin:/usr/bin:/bin
Environment=PYTHONPATH=$(pwd)
Environment=PULSE_SERVER=unix:/tmp/pulse-$USER/native
ExecStartPre=/bin/bash -c 'pulseaudio --start --daemonize || true'
ExecStart=$(pwd)/venv/bin/python $(pwd)/voice_clone_bot.py
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal
SyslogIdentifier=voice-clone-userbot

# Auto restart on
